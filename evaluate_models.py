import matplotlib as mpl
# To get mpl working over ssh, can be disabled otherwise or if causing error
mpl.use('GTKAgg')

import glob
import re
import time
import os
import sys

import tensorflow as tf
import cv2
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import chess
import chess.uci
import stockfish
import rospy
# import baxter_interface

from detect_chessboard import get_keypoints
from create_board_string import create_board_string
from chess_move import my_next_move
from naive_classification import show_naive_classification
from load_maps import create_constants
# from move_baxter import perform_move

"""
	The main program of the project
"""

# The tensorflow inception model used for piece classification
class Model(object):

	def __init__(self, model_path):
		self.session = tf.Session()

		with tf.gfile.FastGFile(model_path, 'rb') as f:
			graph_def = tf.GraphDef()
			graph_def.ParseFromString(f.read())
			_ = tf.import_graph_def(graph_def, name='graph1')

		self.softmax_tensor = self.session.graph.get_tensor_by_name('graph1/final_result:0')

	def predict(self, image_data):
		predictions = self.session.run(self.softmax_tensor, {'graph1/DecodeJpeg:0': image_data})
		return predictions

# Generates a heatmap of the given image by sliding a window of the given size over the image
# and classifying the image under the window, and adding the predictions to the heatmap where the window is
def create_heatmap(image, stepSize, windowSize, model, heatmap, countmap, threshold):
	for y in range(0, image.shape[0], stepSize):
		for x in range(0, image.shape[1], stepSize):
			window = image[y:y+windowSize[1], x:x+windowSize[0]]
			if window.shape[1] != windowSize[0] or \
							window.shape[0] != windowSize[1]:
				continue

			window = np.array(window)
			predictions = model.predict(window)

			for n in range(windowSize[1]):
				for m in range(windowSize[0]):
					countmap[y+n][x+m] += 1
					if threshold > 0.0:
						for i in range(len(predictions[0])):
							if predictions[0][i] >= threshold:
								heatmap[y+n][x+m][i] += predictions[0][i]
					else:
						heatmap[y+n][x+m] += predictions[0]
			
	return heatmap, countmap

# Visualises generated heatmap for testing and evaluation
# Saves 13 heatmap images to directory for inspection, one for each piece type
def visualise_heatmap(img, heatmap, countmap, labels, base_path):
	print "Visualising heatmap"

	for piece in range(len(labels)):
		map = np.zeros((img.shape[0], img.shape[1]))
		for x in range(map.shape[0]):
			for y in range(map.shape[1]):
				map[x][y] = heatmap[x][y][piece]

		ax = sns.heatmap(map, cbar = False)
		plt.axis('off')
		plt.savefig(base_path+labels[piece]+".png", bbox_inches='tight')
		# plt.show()
		plt.clf()

# Creates the points to crop the original image and isolate the chessboard with,
# given the keypoints generated by chessboard detection
def get_crop_points(chessboard_keypoints):
    crop_points = {}
    crop_points["top"] = int(chessboard_keypoints[np.argsort(chessboard_keypoints[:, 1])][80][1]+20)
    crop_points["bottom"] = int(chessboard_keypoints[np.argsort(chessboard_keypoints[:, 1])][0][1]-40)
    crop_points["right"] = int(chessboard_keypoints[np.argsort(chessboard_keypoints[:, 0])][80][0]+20)
    crop_points["left"] = int(chessboard_keypoints[np.argsort(chessboard_keypoints[:, 0])][0][0]-20)
    return crop_points

# Takes the image to classify, isolates the chessboard, and generates a heatmap of the chessboard
def classify_board(imgpath, path):
        corner_keypoints, center_keypoints = get_keypoints(imgpath)
	corner_keypoints = corner_keypoints[0]
	center_keypoints = center_keypoints[0]
	crop_points = get_crop_points(corner_keypoints)

	img = cv2.imread(imgpath)
	img = img[crop_points["bottom"]:crop_points["top"],crop_points["left"]:crop_points["right"]]
	imgpath = "cropped_image.jpeg"
	cv2.imwrite(imgpath, img)
	img = cv2.imread(imgpath)
	corner_keypoints, center_keypoints = get_keypoints(imgpath)
	corner_keypoints = corner_keypoints[0]
	center_keypoints = center_keypoints[0]

		# Show cropped image, for debugging purposes
    	# cv2.imshow("Cropped image", img)
    	# cv2.waitKey(0)

    # 13 dimensional because there are 13 possible classifications
	heatmap = np.zeros((img.shape[0], img.shape[1], 13))
	countmap = np.zeros((img.shape[0], img.shape[1]))

	heatmap, countmap = create_heatmap(img, stepSize, (window_x, window_y), model, heatmap, countmap, 0.0)

	# # Crude thresholding
	# for y in range(len(heatmap)):
	# 	for x in range(len(heatmap[y])):
	# 		for z in range(len(heatmap[y][x])):
	# 			if heatmap[y][x][z] <= 1.5:
	# 				heatmap[y][x][z] = 0
	
	# Visualise the generated heatmap
	visualise_heatmap(img, heatmap, countmap, labels, path + "heatmaps/")

	return heatmap, countmap, center_keypoints, crop_points

# Sums the heatmap data for each piece type in a 10x10 box around it's center
# Returns 64x13 array, each square and the total for each piece type in that square
# Was found to be the most effective of the tested naive labelling methods
def box_total_data(center_keypoints, heatmap, countmap, labels, labels_map):
	square_data = []
	for point in center_keypoints:
    	# 13 possible classifications
		totals = [0,0,0,0,0,0,0,0,0,0,0,0,0]
		for y in range(int(point[0])-5, int(point[0])+5):
			for x in range(int(point[1])-5, int(point[1])+5):
				totals += heatmap[x][y]
		square_data.append(totals)
	return square_data

# Labels each square in the given square_data generated by box_total_data(), 
# using the highest value in the square combined with a precedence system,
# and knowledge of how many of each piece type are on the board
def square_classification_smart_precedence(square_data, labels, labels_map, piece_count_master, precedence_list):
	piece_count = piece_count_master
	square_labels = ["" for i in square_data]
	blank = [0,0,0,0,0,0,0,0,0,0,0,0,0]

	for piece in precedence_list:
		piece_index = labels.index(piece)
		for count in range(piece_count[piece]):
			max_index = -1
			max_value = -1
			for i in range(len(square_data)):
				if square_data[i][piece_index] > max_value:
					max_index = i
					max_value = square_data[i][piece_index]
			square_labels[max_index] = labels_map[labels[piece_index]]
			square_data[max_index] = blank
		for j in range(len(square_data)):
			square_data[j][piece_index] = 0

	return square_labels

# Used for testing the scaling function
def scaling_debug(square_data):
	test = []
	for i in range(len(square_data)):
		test.append(int(square_data[i][5]))
	print np.reshape(test, (8,8))

# Scales the square_data generated by box_total_data
# For each square the data for the piece in that square before the move is scaled by 9x,
# and the squares that the piece in the square could have moved to are scaled by 6x
def apply_scaling(board, square_data, labels, labels_map, board_square_map):
	
	# scaling_debug(square_data)

	square_data_ordered = np.reshape(square_data, (8,8,13))
	square_data_ordered = np.reshape(square_data_ordered, (8,104))
	square_data_ordered = np.flipud(square_data_ordered)
	square_data_ordered = np.reshape(square_data_ordered, (8,8,13))

	square_data_ordered = np.reshape(square_data_ordered, (64,13))

	# scaling_debug(square_data)
	
	for i in range(len(square_data_ordered)):
		if board.piece_at(i) != None:
			piece = letter_count_map[str(board.piece_at(i))]
		else:
			piece = "empty_square"
		square = board_square_map.keys()[board_square_map.values().index(i)]

		square_data_ordered[i][labels.index(piece)] *= 9

		for move in board.legal_moves:
			move = move.uci()
			if move[0:2] == square:
				index = board_square_map[move[2:4]]
				square_data_ordered[index][labels.index(piece)] *= 6

	square_data_ordered = np.reshape(square_data_ordered, (8,8,13))
	square_data_ordered = np.reshape(square_data_ordered, (8,104))
	square_data_ordered = np.flipud(square_data_ordered)
	square_data_ordered = np.reshape(square_data_ordered, (8,8,13))

	square_data = np.reshape(square_data_ordered, (64,13))

	# scaling_debug(square_data)

	return square_data
	
# Gets the move made by the user
# Assumes perfect board state detection
def get_move_made(pre_board, post_board, board_square_map, piece_count, castling_rights, player_colour, letter_count_map):
	# Can be True if a piece is taken
	piece_taken = False
	move_made = ""

	# Check for castling move
	if player_colour == "white":
		if castling_rights == "QUEENSIDE":
			if str(post_board.piece_at(board_square_map["c1"])) == "K":
				return "e1c1", piece_count, piece_taken
		elif castling_rights == "KINGSIDE":
			if str(post_board.piece_at(board_square_map["g1"])) == "K":
				return "e1g1", piece_count, piece_taken
		elif castling_rights == "BOTH":
			if str(post_board.piece_at(board_square_map["c1"])) == "K":
				return "e1c1", piece_count, piece_taken
			elif str(post_board.piece_at(board_square_map["g1"])) == "K":
				return "e1g1", piece_count, piece_taken
	elif player_colour == "black":
		if castling_rights == "QUEENSIDE":
			if str(post_board.piece_at(board_square_map["c8"])) == "k":
				return "e8c8", piece_count, piece_taken
		elif castling_rights == "KINGSIDE":
			if str(post_board.piece_at(board_square_map["g8"])) == "k":
				return "e8g8", piece_count, piece_taken
		elif castling_rights == "BOTH":
			if str(post_board.piece_at(board_square_map["c8"])) == "k":
				return "e8c8", piece_count, piece_taken
			elif str(post_board.piece_at(board_square_map["g8"])) == "k":
				return "e8g8", piece_count, piece_taken

	for move in pre_board.legal_moves:
		move = move.uci()
		if pre_board.piece_at(board_square_map[move[0:2]]) == post_board.piece_at(board_square_map[move[2:4]]):
			if str(pre_board.piece_at(board_square_map[move[2:4]])) != 'None':
				piece_count[letter_count_map[str(pre_board.piece_at(board_square_map[move[2:4]]))]] -= 1
				move_made = move
				piece_taken = True
				break
			else:
				move_made = move
				break

	return move_made, piece_count, piece_taken





base_path = "dissertation_stuff/model_evaluation/"

model_paths = ["3/inception3.pb", "11/inception11.pb", "14/inception14.pb", "22/inception22.pb"]

image_paths = glob.glob(base_path+"images/*.jpeg")

numbers = []
for path in image_paths:
    numbers.append(path.split("/")[3].split(".")[0])

for i in numbers:
    d = base_path+"data/"+str(i)
    if not os.path.exists(d):
        os.makedirs(d)

for i in numbers:
    for j in model_paths:
        d = base_path+"data/"+i+"/"+j.split("/")[0]
        if not os.path.exists(d):
            os.makedirs(d)

labels, labels_map, piece_count, board_square_map, position_map, base_right, base_left, precedence_list, letter_count_map = create_constants()
window_y = 100
window_x = 100
stepSize = 20
labels_path = "data/labels.txt"

for model_path in model_paths:
    model = Model(base_path + model_path)
    
    for imgpath in image_paths:
        number = imgpath.split("/")[3].split(".")[0]
        m_no = model_path.split("/")[0]
        path = base_path+"data/"+str(number)+"/"+str(m_no)+"/"
        print path

        if path == base_path+"data/"+"43/"+"22/":
            out = open(path + "output.txt", "w")
            sys.stdout = out

            if not os.path.exists(path+"heatmaps/"):
                os.makedirs(path+"heatmaps/")

            heatmap, countmap, center_keypoints, crop_points = classify_board(imgpath, path)
            show_naive_classification(center_keypoints, heatmap, countmap, labels, labels_map)
            sys.stdout = sys.__stdout__
            out.close()








